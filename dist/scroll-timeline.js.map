{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/intersection-based-offset.js","../src/scroll-timeline.js"],"sourcesContent":["export function parseLength(str) {\n    return str.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n}","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from './utils';\n\nlet scrollTimelineOptions = new WeakMap();\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement)\n    return document;\n  return scrollSource;\n}\n\nfunction calculateTargetEffectEnd(options) {\n  if (options.iterationCount == Infinity)\n    return Infinity;\n  return Math.max((options.startDelay || 0) + (options.duration || 0) * (options.iterationCount || 1) + (options.endDelay || 0), 0);\n}\n\nlet extensionScrollOffsetFunctions = [];\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push([parseFunction, evaluateFunction]);\n}\n\nfunction calculateMaxScrollOffset(scrollSource, orientation) {\n  // TODO: Support other writing directions.\n  if (orientation == 'block')\n    orientation = 'vertical';\n  else if (orientation == 'inline')\n    orientation = 'horizontal';\n  if (orientation == 'vertical')\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation == 'horizontal')\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n\n}\n\nfunction calculateScrollOffset(autoValue, scrollSource, orientation, offset, fn) {\n  if (fn)\n    return fn(scrollSource, orientation, offset, autoValue == '0%' ? 'start' : 'end');\n  // TODO: Support other writing directions.\n  if (orientation == 'block')\n    orientation = 'vertical';\n  else if (orientation == 'inline')\n    orientation = 'horizontal';\n\n  let maxValue = orientation == 'vertical' ?\n      scrollSource.scrollHeight - scrollSource.clientHeight :\n      scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset == 'auto' ? autoValue : offset);\n  if (parsed[2] == '%')\n    return parseFloat(parsed[1]) * maxValue / 100;\n  return parseFloat(parsed[1]);\n}\n\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange == 'auto') {\n    timeRange = 0;\n    let options = scrollTimelineOptions.get(scrollTimeline).animationOptions;\n    for (let i = 0; i < options.length; i++) {\n      timeRange = Math.max(timeRange, calculateTargetEffectEnd(options[i]));\n    }\n    if (timeRange == Infinity)\n      timeRange = 0;\n  }\n  return timeRange;\n}\n\nfunction updateInternal() {\n  let animations = scrollTimelineOptions.get(this).animations;\n  if (animations.length == 0)\n    return;\n  let currentTime = this.currentTime;\n  for (let i = 0; i < animations.length; i++) {\n    // The web-animations spec says to throw a TypeError if you try to seek to\n    // an unresolved time value from a resolved time value, so to polyfill the\n    // expected behavior we cancel the underlying animation.\n    if (currentTime == null) {\n      if (animations[i].playState == 'paused')\n        animations[i].cancel();\n    } else {\n      animations[i].currentTime = currentTime;\n    }\n  }\n}\n\nfunction addAnimation(scrollTimeline, animation, options) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  let animationOptions = scrollTimelineOptions.get(scrollTimeline).animationOptions;\n  animations.push(animation);\n  animationOptions.push(options);\n  updateInternal.apply(scrollTimeline);\n}\n\nfunction removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  let index = animations.indexOf(animation);\n  if (index == -1)\n    return;\n  animations.splice(index, 1);\n  scrollTimelineOptions.get(scrollTimeline).animationOptions.splice(index, 1);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: 'block',\n      startScrollOffset: 'auto',\n      endScrollOffset: 'auto',\n      timeRange: 'auto',\n      fill: 'none',\n\n      // Internal members\n      animations: [],\n      animationOptions: [],\n      updateFunction: updateInternal.bind(this),\n    });\n    this.scrollSource = options && options.scrollSource || document.scrollingElement;\n    this.orientation = options && options.orientation || 'block';\n    this.startScrollOffset = options && options.startScrollOffset || 'auto';\n    this.endScrollOffset = options && options.endScrollOffset || 'auto';\n    this.timeRange = options && options.timeRange || 'auto';\n    this.fill = options && options.fill || 'none';\n  }\n\n  set scrollSource(element) {\n    let internal = scrollTimelineOptions.get(this);\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener('scroll', internal.updateFunction);\n    if (!(element instanceof Element))\n      element = document.scrollingElement;\n    scrollTimelineOptions.get(this).scrollSource = element;\n    scrollEventSource(element).addEventListener('scroll', internal.updateFunction);\n    updateInternal.apply(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (['block', 'inline', 'horizontal', 'vertical'].indexOf(orientation) == -1)\n      orientation = 'block';\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal.apply(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set startScrollOffset(offset) {\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i][0](offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).startScrollOffsetFunction = extensionScrollOffsetFunctions[i][1];\n        break;\n      }\n    }\n    scrollTimelineOptions.get(this).startScrollOffset = offset;\n    updateInternal.apply(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i][0](offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction = extensionScrollOffsetFunctions[i][1];\n        break;\n      }\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal.apply(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(offset) {\n    scrollTimelineOptions.get(this).timeRange = offset;\n    updateInternal.apply(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource)\n      return unresolved;\n    let startOffset = calculateScrollOffset('0%', this.scrollSource, this.orientation, this.startScrollOffset, scrollTimelineOptions.get(this).startScrollOffsetFunction);\n    let endOffset = calculateScrollOffset('100%', this.scrollSource, this.orientation, this.endScrollOffset, scrollTimelineOptions.get(this).endScrollOffsetFunction);\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    let currentScrollOffset = this.scrollSource.scrollTop;\n\n    // Step 3\n    if (currentScrollOffset < startOffset) {\n      if (this.fill == 'none' || this.fill == 'forwards')\n        return unresolved;\n      return 0;\n    }\n\n    // Step 4\n    if (currentScrollOffset >= endOffset) {\n      if (endOffset < calculateMaxScrollOffset(this.scrollSource, this.orientation) &&\n          (this.fill == 'none' || this.fill == 'backwards')) {\n        return unresolved;\n      }\n      return timeRange;\n    }\n\n    // Step 5\n    return (currentScrollOffset - startOffset) / (endOffset - startOffset) * timeRange;\n  }\n};\n\nexport function installPolyfill(scope) {\n  scope.ScrollTimeline = ScrollTimeline;\n  let nativeAnimate = scope.Element.prototype.animate;\n  scope.Element.prototype.animate = function(keyframes, options) {\n    let timeline = options.timeline;\n    if (!timeline || !(timeline instanceof ScrollTimeline)) {\n      return nativeAnimate.apply(this, arguments);\n    }\n    delete options.timeline;\n    let animation = nativeAnimate.apply(this, arguments);\n    // TODO: Create a proxy for the animation to control and fake the animation\n    // play state.\n    animation.pause();\n    addAnimation(timeline, animation, options);\n    return animation;\n  };\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from './utils';\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n    // 1 length maps to all positions.\n    [[TOP, RIGHT, BOTTOM, LEFT]],\n    // 2 lengths maps to vertical and horizontal margins.\n    [[TOP, BOTTOM], [RIGHT, LEFT]],\n    // 3 lengths maps to top, horizontal, bottom margins.\n    [[TOP], [RIGHT, LEFT], [BOTTOM]],\n    // 4 lengths maps to each component.\n    [[TOP], [RIGHT], [BOTTOM], [LEFT]]];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: 'start',\n      threshold: 0,\n      rootMargin: [[0, 'px'], [0, 'px'], [0, 'px'], [0, 'px']],\n    });\n    this.target = value.target;\n    this.edge = value.edge || 'start';\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || '0px 0px 0px 0px';\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error('Intersection target must be an element.');\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if (['start', 'end'].indexOf(value) == -1)\n      return;\n    IntersectionOptions.get(this).edge = value;\n  }\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a RangeError for out of range threshold:\n    // https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n    if (threshold < 0 || threshold > 1)\n      throw RangeError('threshold must be in the range [0, 1]');\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/)\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError('rootMargin must contain between 1 and 4 length components');\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i]);\n      if (!parsedValue)\n        throw TypeError('Unrecognized rootMargin length');\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [parseFloat(parsedValue[1]), parsedValue[2]];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this).rootMargin.map(\n        (margin) => { return margin.join(''); }).join(' ');\n  }\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n};\n\nexport function parseOffset(value) {\n  if (value.target)\n    return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == '%')\n    return length[0] * containerSize / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == 'block')\n    orientation = 'vertical';\n  else if (orientation == 'inline')\n    orientation = 'horizontal';\n  let originalViewport = scrollSource == document.scrollingElement ?\n      { left: 0, right: scrollSource.clientWidth,\n        top: 0, bottom: scrollSource.clientHeight,\n        width: scrollSource.clientWidth, height: scrollSource.clientHeight } :\n      scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(resolveLength(parsedMargins[i], (i % 2 == 0 ? originalViewport.height : originalViewport.width)));\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width: originalViewport.right - originalViewport.left + computedMargins[LEFT] + computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height: originalViewport.bottom - originalViewport.top + computedMargins[TOP] + computedMargins[BOTTOM],\n  }\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == 'start')\n    threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == 'vertical') {\n    let point = target.top + target.height * threshold - viewport.top + scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == 'end')\n        return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == 'end')\n        return point - viewport.height;\n      return point;\n    }\n  } else { // orientation == 'horizontal'\n    let point = target.left + target.width * threshold - viewport.left + scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == 'end')\n        return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == 'end')\n        return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport * as scrolltimeline from './scroll-timeline-base.js';\nimport {calculateOffset, parseOffset} from \"./intersection-based-offset\";\n\n// TODO: explore other options or name, when we install our `ScrollTimeline` on `Window` object\n//  this module import will shadow that already existing window object\n//  if we decided to continue to offer module async version, we can expose it as `ScrollTimelinePolyfill` or somthing\n// export { ScrollTimeline as default } from './scroll-timeline-base.js';\n\nscrolltimeline.installScrollOffsetExtension(parseOffset, calculateOffset);\nscrolltimeline.installPolyfill(window);\n\n"],"names":["parseLength","str","trim","match","scrollTimelineOptions","WeakMap","scrollEventSource","scrollSource","document","scrollingElement","calculateTargetEffectEnd","options","Infinity","iterationCount","Math","max","startDelay","duration","endDelay","extensionScrollOffsetFunctions","calculateScrollOffset","autoValue","orientation","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","parsed","parseFloat","updateInternal","animations","get","this","length","currentTime","i","playState","cancel","addAnimation","scrollTimeline","animation","animationOptions","push","apply","ScrollTimeline","set","startScrollOffset","endScrollOffset","timeRange","fill","updateFunction","bind","_createClass","element","internal","removeEventListener","Element","addEventListener","indexOf","startScrollOffsetFunction","result","undefined","endScrollOffsetFunction","startOffset","endOffset","calculateTimeRange","currentScrollOffset","scrollTop","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","value","target","edge","threshold","rootMargin","clamp","Error","RangeError","margins","split","TypeError","parsedMargins","parsedValue","positions","j","map","margin","join","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","scrollLeft","scope","nativeAnimate","prototype","animate","keyframes","timeline","arguments","pause","scrolltimeline","window"],"mappings":"oPAAgBA,EAAYC,GACxB,OAAOA,EAAIC,OAAOC,MAAM,+BCe5B,IAAIC,EAAwB,IAAIC,QAEhC,SAASC,EAAkBC,GACzB,OAAIA,IAAiBC,SAASC,iBACrBD,SACFD,EAGT,SAASG,EAAyBC,GAChC,OAA8BC,UAA1BD,EAAQE,eACHD,SACFE,KAAKC,KAAKJ,EAAQK,YAAc,IAAML,EAAQM,UAAY,IAAMN,EAAQE,gBAAkB,IAAMF,EAAQO,UAAY,GAAI,GAGjI,IAAIC,EAAiC,GAkBrC,SAASC,EAAsBC,EAAWd,EAAce,EAAaC,EAAQC,GAC3E,GAAIA,EACF,OAAOA,EAAGjB,EAAce,EAAaC,EAAqB,MAAbF,EAAoB,QAAU,OAE1D,SAAfC,EACFA,EAAc,WACQ,UAAfA,IACPA,EAAc,cAEhB,IAAIG,EAA0B,YAAfH,EACXf,EAAamB,aAAenB,EAAaoB,aACzCpB,EAAaqB,YAAcrB,EAAasB,YACxCC,EAAS9B,EAAsB,QAAVuB,EAAmBF,EAAYE,GACxD,MAAiB,KAAbO,EAAO,GACFC,WAAWD,EAAO,IAAML,EAAW,IACrCM,WAAWD,EAAO,IAiB3B,SAASE,IACP,IAAIC,EAAa7B,EAAsB8B,IAAIC,MAAMF,WACjD,GAAyB,GAArBA,EAAWG,OAGf,IADA,IAAIC,EAAcF,KAAKE,YACdC,EAAI,EAAGA,EAAIL,EAAWG,OAAQE,IAIlB,MAAfD,EAC6B,UAA3BJ,EAAWK,GAAGC,WAChBN,EAAWK,GAAGE,SAEhBP,EAAWK,GAAGD,YAAcA,EAKlC,SAASI,EAAaC,EAAgBC,EAAWhC,GAC/C,IAAIsB,EAAa7B,EAAsB8B,IAAIQ,GAAgBT,WACvDW,EAAmBxC,EAAsB8B,IAAIQ,GAAgBE,iBACjEX,EAAWY,KAAKF,GAChBC,EAAiBC,KAAKlC,GACtBqB,EAAec,MAAMJ,OAYVK,aACX,WAAYpC,GACVP,EAAsB4C,IAAIb,KAAM,CAC9B5B,aAAc,KACde,YAAa,QACb2B,kBAAmB,OACnBC,gBAAiB,OACjBC,UAAW,OACXC,KAAM,OAGNnB,WAAY,GACZW,iBAAkB,GAClBS,eAAgBrB,EAAesB,KAAKnB,QAEtCA,KAAK5B,aAAeI,GAAWA,EAAQJ,cAAgBC,SAASC,iBAChE0B,KAAKb,YAAcX,GAAWA,EAAQW,aAAe,QACrDa,KAAKc,kBAAoBtC,GAAWA,EAAQsC,mBAAqB,OACjEd,KAAKe,gBAAkBvC,GAAWA,EAAQuC,iBAAmB,OAC7Df,KAAKgB,UAAYxC,GAAWA,EAAQwC,WAAa,OACjDhB,KAAKiB,KAAOzC,GAAWA,EAAQyC,MAAQ,cApB3CG,sCAuBmBC,GACf,IAAIC,EAAWrD,EAAsB8B,IAAIC,MACrCA,KAAK5B,cACPD,EAAkB6B,KAAK5B,cAAcmD,oBAAoB,SAAUD,EAASJ,gBACxEG,aAAmBG,UACvBH,EAAUhD,SAASC,kBACrBL,EAAsB8B,IAAIC,MAAM5B,aAAeiD,EAC/ClD,EAAkBkD,GAASI,iBAAiB,SAAUH,EAASJ,gBAC/DrB,EAAec,MAAMX,sBAIrB,OAAO/B,EAAsB8B,IAAIC,MAAM5B,+CAGzBe,IAC6D,GAAvE,CAAC,QAAS,SAAU,aAAc,YAAYuC,QAAQvC,KACxDA,EAAc,SAChBlB,EAAsB8B,IAAIC,MAAMb,YAAcA,EAC9CU,EAAec,MAAMX,sBAIrB,OAAO/B,EAAsB8B,IAAIC,MAAMb,oDAGnBC,GAEpBnB,EAAsB8B,IAAIC,MAAM2B,0BAA4B,KAC5D,IAAK,IAAIxB,EAAI,EAAGA,EAAInB,EAA+BiB,OAAQE,IAAK,CAC9D,IAAIyB,EAAS5C,EAA+BmB,GAAG,GAAGf,GAClD,QAAeyC,IAAXD,EAAsB,CACxBxC,EAASwC,EACT3D,EAAsB8B,IAAIC,MAAM2B,0BAA4B3C,EAA+BmB,GAAG,GAC9F,OAGJlC,EAAsB8B,IAAIC,MAAMc,kBAAoB1B,EACpDS,EAAec,MAAMX,sBAIrB,OAAO/B,EAAsB8B,IAAIC,MAAMc,wDAGrB1B,GAElBnB,EAAsB8B,IAAIC,MAAM8B,wBAA0B,KAC1D,IAAK,IAAI3B,EAAI,EAAGA,EAAInB,EAA+BiB,OAAQE,IAAK,CAC9D,IAAIyB,EAAS5C,EAA+BmB,GAAG,GAAGf,GAClD,QAAeyC,IAAXD,EAAsB,CACxBxC,EAASwC,EACT3D,EAAsB8B,IAAIC,MAAM8B,wBAA0B9C,EAA+BmB,GAAG,GAC5F,OAGJlC,EAAsB8B,IAAIC,MAAMe,gBAAkB3B,EAClDS,EAAec,MAAMX,sBAIrB,OAAO/B,EAAsB8B,IAAIC,MAAMe,gDAG3B3B,GACZnB,EAAsB8B,IAAIC,MAAMgB,UAAY5B,EAC5CS,EAAec,MAAMX,sBAIrB,OAAO/B,EAAsB8B,IAAIC,MAAMgB,8CAOvC,IAAKhB,KAAK5B,aACR,OAFe,KAGjB,IAtL8BA,EAAce,EAsLxC4C,EAAc9C,EAAsB,KAAMe,KAAK5B,aAAc4B,KAAKb,YAAaa,KAAKc,kBAAmB7C,EAAsB8B,IAAIC,MAAM2B,2BACvIK,EAAY/C,EAAsB,OAAQe,KAAK5B,aAAc4B,KAAKb,YAAaa,KAAKe,gBAAiB9C,EAAsB8B,IAAIC,MAAM8B,yBACrId,EAzJR,SAA4BT,GAC1B,IAAIS,EAAYT,EAAeS,UAC/B,GAAiB,QAAbA,EAAqB,CACvBA,EAAY,EAEZ,IADA,IAAIxC,EAAUP,EAAsB8B,IAAIQ,GAAgBE,iBAC/CN,EAAI,EAAGA,EAAI3B,EAAQyB,OAAQE,IAClCa,EAAYrC,KAAKC,IAAIoC,EAAWzC,EAAyBC,EAAQ2B,KAElD1B,UAAbuC,IACFA,EAAY,GAEhB,OAAOA,EA8IWiB,CAAmBjC,MAG/BkC,EAAsBlC,KAAK5B,aAAa+D,UAG5C,OAAID,EAAsBH,EACP,QAAb/B,KAAKiB,MAA+B,YAAbjB,KAAKiB,KAZjB,OAkBbiB,GAAuBF,EACrBA,GAtMwB5D,EAsMa4B,KAAK5B,aApM/B,UAF2Be,EAsMkBa,KAAKb,aAnMnEA,EAAc,WACQ,UAAfA,IACPA,EAAc,cACG,YAAfA,EACKf,EAAamB,aAAenB,EAAaoB,aAC1B,cAAfL,EACAf,EAAaqB,YAAcrB,EAAasB,sBA8L3B,QAAbM,KAAKiB,MAA+B,aAAbjB,KAAKiB,MApBlB,KAuBRD,GAIDkB,EAAsBH,IAAgBC,EAAYD,GAAef,WCjOzEoB,EAAsB,IAAIlE,QASxBmE,EAAa,CAEf,CAAC,CANO,EACE,EACC,EACF,IAKT,CAAC,CARO,EAEG,GAMK,CAPN,EAED,IAOT,CAAC,CAVO,GAUA,CATE,EAED,GAOc,CARZ,IAUX,CAAC,CAZO,GAYA,CAXE,GAWO,CAVN,GAUgB,CATlB,KAWPC,aACJ,WAAYC,GACVH,EAAoBvB,IAAIb,KAAM,CAC5BwC,OAAQ,KACRC,KAAM,QACNC,UAAW,EACXC,WAAY,CAAC,CAAC,EAAG,MAAO,CAAC,EAAG,MAAO,CAAC,EAAG,MAAO,CAAC,EAAG,SAEpD3C,KAAKwC,OAASD,EAAMC,OACpBxC,KAAKyC,KAAOF,EAAME,MAAQ,QAC1BzC,KAAK0C,UAAYH,EAAMG,WAAa,EACpC1C,KAAK2C,WAAaJ,EAAMI,YAAc,kBACtC3C,KAAK4C,MAAQL,EAAMK,QAAS,yCAGnBvB,GACT,KAAMA,aAAmBG,SAEvB,MADAY,EAAoBrC,IAAIC,MAAMwC,OAAS,KACjCK,MAAM,2CAEdT,EAAoBrC,IAAIC,MAAMwC,OAASnB,kBAGvC,OAAOe,EAAoBrC,IAAIC,MAAMwC,kCAG9BD,IACiC,GAApC,CAAC,QAAS,OAAOb,QAAQa,KAE7BH,EAAoBrC,IAAIC,MAAMyC,KAAOF,mBAGrC,OAAOH,EAAoBrC,IAAIC,MAAMyC,qCAGzBF,GACZ,IAAIG,EAAY9C,WAAW2C,GAG3B,GAAIG,EAAY,GAAKA,EAAY,EAC/B,MAAMI,WAAW,yCACnBV,EAAoBrC,IAAIC,MAAM0C,UAAYA,kBAG1C,OAAON,EAAoBrC,IAAIC,MAAM0C,2CAGxBH,GACb,IAAIQ,EAAUR,EAAMS,MAAM,MAC1B,GAAID,EAAQ9C,OAAS,GAAK8C,EAAQ9C,OAAS,EACzC,MAAMgD,UAAU,6DAElB,IADA,IAAIC,EAAgB,CAAC,GAAI,GAAI,GAAI,IACxB/C,EAAI,EAAGA,EAAI4C,EAAQ9C,OAAQE,IAAK,CACvC,IAAIgD,EAActF,EAAYkF,EAAQ5C,IACtC,IAAKgD,EACH,MAAMF,UAAU,kCAElB,IADA,IAAIG,EAAYf,EAAWU,EAAQ9C,OAAS,GAAGE,GACtCkD,EAAI,EAAGA,EAAID,EAAUnD,OAAQoD,IACpCH,EAAcE,EAAUC,IAAM,CAACzD,WAAWuD,EAAY,IAAKA,EAAY,IAG3Ef,EAAoBrC,IAAIC,MAAM2C,WAAaO,kBAI3C,OAAOd,EAAoBrC,IAAIC,MAAM2C,WAAWW,IAC5C,SAACC,GAAa,OAAOA,EAAOC,KAAK,MAAQA,KAAK,iCAE1CjB,GAGRH,EAAoBrC,IAAIC,MAAM4C,QAAUL,WD1E1CvD,EAA+B0B,KAAK,CC4ErC,SAE2B6B,GAC1B,GAAIA,EAAMC,OACR,WAAWF,EAAwBC,aAWPnE,EAAce,EAAaC,EAAQqE,GAE9C,SAAftE,EACFA,EAAc,WACQ,UAAfA,IACPA,EAAc,cAUhB,IATA,IAdqBc,EAcjByD,EAAmBtF,GAAgBC,SAASC,iBAC5C,CAAEqF,KAAM,EAAGC,MAAOxF,EAAasB,YAC7BmE,IAAK,EAAGC,OAAQ1F,EAAaoB,aAC7BuE,MAAO3F,EAAasB,YAAasE,OAAQ5F,EAAaoB,cACxDpB,EAAa6F,wBAGbf,EAAgBd,EAAoBrC,IAAIX,GAAQuD,WAChDuB,EAAkB,GACb/D,EAAI,EAAGA,EAAI,EAAGA,IACrB+D,EAAgBxD,KAvBD,MADIT,EAwBgBiD,EAAc/C,IAvBxC,GACFF,EAAO,IAsBwCE,EAAI,GAAK,EAAIuD,EAAiBM,OAASN,EAAiBK,OAtB3E,IAG9B9D,EAAO,IAqBd,IAAIkE,EACIT,EAAiBC,KAAOO,EAtHrB,GAqHPC,EAGKT,EAAiBE,MAAQF,EAAiBC,KAAOO,EAxH/C,GAwHuEA,EA1HtE,GAuHRC,EAIGT,EAAiBG,IAAMK,EA5HpB,GAwHNC,EAMMT,EAAiBI,OAASJ,EAAiBG,IAAMK,EA9HjD,GA8HwEA,EA5HrE,GA+HTE,EAAUhC,EAAoBrC,IAAIX,GAAQwD,MAC1CJ,EAASpD,EAAOoD,OAAOyB,wBACvBvB,EAAYtD,EAAOsD,UAKvB,GAHmB,SAAftD,EAAOqD,OACTC,EAAY,EAAIA,GAEC,YAAfvD,EAA2B,CAC7B,IAAIkF,EAAQ7B,EAAOqB,IAAMrB,EAAOwB,OAAStB,EAAYyB,EAAe/F,EAAa+D,UACjF,OAAIiC,EACiB,OAAfhF,EAAOqD,KACF9D,KAAKC,IAAI,EAAGyF,EAAQF,GACtBxF,KAAK2F,IAAID,EAAOjG,EAAamB,aAAe4E,GAEhC,OAAf/E,EAAOqD,KACF4B,EAAQF,EACVE,EAGT,IAAIA,EAAQ7B,EAAOmB,KAAOnB,EAAOuB,MAAQrB,EAAYyB,EAAgB/F,EAAamG,WAClF,OAAIH,EACiB,OAAfhF,EAAOqD,KACF9D,KAAKC,IAAI,EAAGyF,EAAQF,GACtBxF,KAAK2F,IAAID,EAAOjG,EAAaqB,YAAc0E,GAE/B,OAAf/E,EAAOqD,KACF4B,EAAQF,EACVE,KDkEZ,SAE+BG,GAC9BA,EAAM5D,eAAiBA,EACvB,IAAI6D,EAAgBD,EAAMhD,QAAQkD,UAAUC,QAC5CH,EAAMhD,QAAQkD,UAAUC,QAAU,SAASC,EAAWpG,GACpD,IAAIqG,EAAWrG,EAAQqG,SACvB,KAAKA,GAAcA,aAAoBjE,GACrC,OAAO6D,EAAc9D,MAAMX,KAAM8E,kBAE5BtG,EAAQqG,SACf,IAAIrE,EAAYiE,EAAc9D,MAAMX,KAAM8E,WAK1C,OAFAtE,EAAUuE,QACVzE,EAAauE,EAAUrE,EAAWhC,GAC3BgC,GE5OXwE,CAA+BC"}