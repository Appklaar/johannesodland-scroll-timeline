{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(str) {\n  let matches = str.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if( matches ) {\n    return {\n      value: matches[1],\n      unit: matches[2],\n    }\n  }\n  return null\n}","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from './utils';\n\nlet scrollTimelineOptions = new WeakMap();\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement)\n    return document;\n  return scrollSource;\n}\n\nexport function calculateTargetEffectEnd(options) {\n  if (options.iterationCount === Infinity)\n    return Infinity;\n  return Math.max((options.startDelay || 0) + (options.duration || 0) * (options.iterationCount || 1) + (options.endDelay || 0), 0);\n}\n\nlet extensionScrollOffsetFunctions = [];\n\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction\n  });\n  return extensionScrollOffsetFunctions\n}\n\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // TODO: Support other writing directions.\n  if (orientation === 'block')\n    orientation = 'vertical';\n  else if (orientation === 'inline')\n    orientation = 'horizontal';\n  if (orientation === 'vertical')\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === 'horizontal')\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n\n}\n\nexport function calculateScrollOffset(autoValue, scrollSource, orientation, offset, fn) {\n  if (fn)\n    return fn(scrollSource, orientation, offset, autoValue === '0%' ? 'start' : 'end');\n  // TODO: Support other writing directions.\n  if (orientation === 'block')\n    orientation = 'vertical';\n  else if (orientation === 'inline')\n    orientation = 'horizontal';\n\n  let maxValue = orientation === 'vertical' ?\n    scrollSource.scrollHeight - scrollSource.clientHeight :\n    scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === 'auto' ? autoValue : offset);\n  if (parsed.unit === '%')\n    return parseFloat(parsed.value) * maxValue / 100;\n  return parseFloat(parsed.value);\n}\n\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange === 'auto') {\n    timeRange = 0;\n    let options = scrollTimelineOptions.get(scrollTimeline).animationOptions;\n    for (let i = 0; i < options.length; i++) {\n      timeRange = Math.max(timeRange, calculateTargetEffectEnd(options[i]));\n    }\n    if (timeRange === Infinity)\n      timeRange = 0;\n  }\n  return timeRange;\n}\n\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0)\n    return;\n  let currentTime = scrollTimelineInstance.currentTime;\n  for (let i = 0; i < animations.length; i++) {\n    // The web-animations spec says to throw a TypeError if you try to seek to\n    // an unresolved time value from a resolved time value, so to polyfill the\n    // expected behavior we cancel the underlying animation.\n    if (currentTime == null) {\n      if (animations[i].playState === 'paused')\n        animations[i].cancel();\n    } else {\n      animations[i].currentTime = currentTime;\n    }\n  }\n}\n\nexport function addAnimation(scrollTimeline, animation, options) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  let animationOptions = scrollTimelineOptions.get(scrollTimeline).animationOptions;\n  animations.push(animation);\n  animationOptions.push(options);\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nfunction removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  let index = animations.indexOf(animation);\n  if (index === -1)\n    return;\n  animations.splice(index, 1);\n  scrollTimelineOptions.get(scrollTimeline).animationOptions.splice(index, 1);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: 'block',\n      startScrollOffset: 'auto',\n      endScrollOffset: 'auto',\n      timeRange: 'auto',\n      fill: 'none',\n\n      // Internal members\n      animations: [],\n      animationOptions: [],\n    });\n    this.scrollSource = options && options.scrollSource || document.scrollingElement;\n    this.orientation = options && options.orientation || 'block';\n    this.startScrollOffset = options && options.startScrollOffset || 'auto';\n    this.endScrollOffset = options && options.endScrollOffset || 'auto';\n    this.timeRange = options && options.timeRange || 'auto';\n    this.fill = options && options.fill || 'none';\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener('scroll', () => updateInternal(this));\n    if (!(element instanceof Element))\n      element = document.scrollingElement;\n    scrollTimelineOptions.get(this).scrollSource = element;\n    scrollEventSource(element).addEventListener('scroll', () => updateInternal(this));\n    updateInternal(this)\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (['block', 'inline', 'horizontal', 'vertical'].indexOf(orientation) === -1)\n      orientation = 'block';\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set startScrollOffset(offset) {\n    let currentStlOptions =  scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction = extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction = extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(offset) {\n    scrollTimelineOptions.get(this).timeRange = offset;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource)\n      return unresolved;\n    let startOffset = calculateScrollOffset('0%', this.scrollSource, this.orientation, this.startScrollOffset, scrollTimelineOptions.get(this).startScrollOffsetFunction);\n    let endOffset = calculateScrollOffset('100%', this.scrollSource, this.orientation, this.endScrollOffset, scrollTimelineOptions.get(this).endScrollOffsetFunction);\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    let currentScrollOffset = this.scrollSource.scrollTop;\n\n    // Step 3\n    if (currentScrollOffset < startOffset) {\n      if (this.fill === 'none' || this.fill === 'forwards')\n        return unresolved;\n      return 0;\n    }\n\n    // Step 4\n    if (currentScrollOffset >= endOffset) {\n      if (endOffset < calculateMaxScrollOffset(this.scrollSource, this.orientation) &&\n        (this.fill === 'none' || this.fill === 'backwards')) {\n        return unresolved;\n      }\n      return timeRange;\n    }\n\n    // Step 5\n    return (currentScrollOffset - startOffset) / (endOffset - startOffset) * timeRange;\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {parseLength} from './utils';\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [[TOP, BOTTOM], [RIGHT, LEFT]],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]]];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: 'start',\n      threshold: 0,\n      rootMargin: [[0, 'px'], [0, 'px'], [0, 'px'], [0, 'px']],\n    });\n    this.target = value.target;\n    this.edge = value.edge || 'start';\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || '0px 0px 0px 0px';\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error('Intersection target must be an element.');\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if (['start', 'end'].indexOf(value) == -1)\n      return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a RangeError for out of range threshold:\n    // https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n    if (threshold < 0 || threshold > 1)\n      throw RangeError('threshold must be in the range [0, 1]');\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/)\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError('rootMargin must contain between 1 and 4 length components');\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i]);\n      if (!parsedValue)\n        throw TypeError('Unrecognized rootMargin length');\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [parseFloat(parsedValue.value), parsedValue.unit];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this).rootMargin.map(\n      (margin) => {\n        return margin.join('');\n      }).join(' ');\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n};\n\nexport function parseOffset(value) {\n  if (value.target)\n    return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == '%')\n    return length[0] * containerSize / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == 'block')\n    orientation = 'vertical';\n  else if (orientation == 'inline')\n    orientation = 'horizontal';\n  let originalViewport = scrollSource == document.scrollingElement ?\n    {\n      left: 0, right: scrollSource.clientWidth,\n      top: 0, bottom: scrollSource.clientHeight,\n      width: scrollSource.clientWidth, height: scrollSource.clientHeight\n    } :\n    scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(resolveLength(parsedMargins[i], (i % 2 == 0 ? originalViewport.height : originalViewport.width)));\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width: originalViewport.right - originalViewport.left + computedMargins[LEFT] + computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height: originalViewport.bottom - originalViewport.top + computedMargins[TOP] + computedMargins[BOTTOM],\n  }\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == 'start')\n    threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == 'vertical') {\n    let point = target.top + target.height * threshold - viewport.top + scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == 'end')\n        return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == 'end')\n        return point - viewport.height;\n      return point;\n    }\n  } else { // orientation == 'horizontal'\n    let point = target.left + target.width * threshold - viewport.left + scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == 'end')\n        return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == 'end')\n        return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { ScrollTimeline, installScrollOffsetExtension, addAnimation } from \"./scroll-timeline-base\";\nimport {calculateOffset, parseOffset} from \"./intersection-based-offset\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\n\n/**\n * Decides whether to use native Element.prototype.animate function in regular fashion or pass it to our polyfill so its current time is driven by scroll event\n * @param keyframes {Object} array of keyframe objects\n * @param options {Object} WAAPI options object\n * @returns {Function}\n */\nconst animate = function (keyframes, options) {\n  let timeline = options.timeline;\n  if (!timeline || !(timeline instanceof ScrollTimeline)) {\n    return nativeElementAnimate.apply(this, [keyframes, options]);\n  }\n  delete options.timeline;\n  let animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  // TODO: Create a proxy for the animation to control and fake the animation\n  // play state.\n  animation.pause();\n  addAnimation(timeline, animation, options);\n  return animation;\n};\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (!Reflect.defineProperty(window, 'ScrollTimeline', {value: ScrollTimeline})) {\n  throw Error(\"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\")\n}\n\nif (!Reflect.defineProperty(Element.prototype, 'animate', {value: animate})) {\n  throw Error(\"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\")\n}\n"],"names":["parseLength","str","matches","trim","match","value","unit","scrollTimelineOptions","WeakMap","scrollEventSource","scrollSource","document","scrollingElement","calculateTargetEffectEnd","options","Infinity","iterationCount","Math","max","startDelay","duration","endDelay","extensionScrollOffsetFunctions","calculateScrollOffset","autoValue","orientation","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","parsed","parseFloat","updateInternal","scrollTimelineInstance","animations","get","length","currentTime","i","playState","cancel","ScrollTimeline","set","this","startScrollOffset","endScrollOffset","timeRange","fill","animationOptions","_createClass","element","removeEventListener","_this","Element","addEventListener","indexOf","currentStlOptions","startScrollOffsetFunction","result","parse","undefined","evaluate","endScrollOffsetFunction","startOffset","endOffset","scrollTimeline","calculateTimeRange","currentScrollOffset","scrollTop","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","RangeError","margins","split","TypeError","parsedMargins","parsedValue","positions","j","map","margin","join","nativeElementAnimate","window","prototype","animate","push","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","scrollLeft","Reflect","defineProperty","keyframes","timeline","apply","animation","pause","addAnimation"],"mappings":"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"}