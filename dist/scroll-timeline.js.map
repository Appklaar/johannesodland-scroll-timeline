{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(str) {\n  let matches = str.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    return {\n      value: matches[1],\n      unit: matches[2],\n    };\n  }\n  return null;\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nconst AUTO = \"auto\";\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let currentTime = scrollTimelineInstance.currentTime;\n  for (let i = 0; i < animations.length; i++) {\n    // The web-animations spec says to throw a TypeError if you try to seek to\n    // an unresolved time value from a resolved time value, so to polyfill the\n    // expected behavior we cancel the underlying animation.\n    if (currentTime == null) {\n      if (animations[i].playState === \"paused\") animations[i].cancel();\n    } else {\n      animations[i].currentTime = currentTime;\n    }\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of AUTO\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange === AUTO) {\n    timeRange = 0;\n    let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n    for (let i = 0; i < animations.length; i++) {\n      timeRange = Math.max(timeRange, calculateTargetEffectEnd(animations[i]));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue === \"0%\" ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === AUTO ? autoValue : offset);\n  if (parsed.unit === \"%\") return (parseFloat(parsed.value) * maxValue) / 100;\n  return parseFloat(parsed.value);\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  let index = animations.indexOf(animation);\n  if (index === -1) return;\n  animations.splice(index, 1);\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function addAnimation(scrollTimeline, animation, options) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  animations.push(animation);\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: AUTO,\n      endScrollOffset: AUTO,\n      timeRange: AUTO,\n      fill: \"none\",\n\n      // Internal members\n      animations: [],\n    });\n    this.scrollSource =\n      (options && options.scrollSource) || document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || AUTO;\n    this.endScrollOffset = (options && options.endScrollOffset) || AUTO;\n    this.timeRange = (options && options.timeRange) || AUTO;\n    this.fill = (options && options.fill) || \"none\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    if (!(element instanceof Element)) element = document.scrollingElement;\n    scrollTimelineOptions.get(this).scrollSource = element;\n    scrollEventSource(element).addEventListener(\"scroll\", () =>\n      updateInternal(this)\n    );\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    )\n      orientation = \"block\";\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set startScrollOffset(offset) {\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(offset) {\n    scrollTimelineOptions.get(this).timeRange = offset;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    let startOffset = calculateScrollOffset(\n      \"0%\",\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      \"100%\",\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    // TODO: Support other writing directions.\n    let currentScrollOffset = this.scrollSource.scrollTop\n    if (this.orientation === 'inline' || this.orientation === 'horizontal') {\n      currentScrollOffset = this.scrollSource.scrollLeft\n    }\n\n    // Step 3\n    if (currentScrollOffset < startOffset) {\n      if (this.fill === \"none\" || this.fill === \"forwards\") return unresolved;\n      return 0;\n    }\n\n    // Step 4\n    if (currentScrollOffset >= endOffset) {\n      if (\n        endOffset <\n          calculateMaxScrollOffset(this.scrollSource, this.orientation) &&\n        (this.fill === \"none\" || this.fill === \"backwards\")\n      ) {\n        return unresolved;\n      }\n      return timeRange;\n    }\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","import {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n  removeAnimation\n} from \"./scroll-timeline-base\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\n/**\n * Decides whether to use native Element.prototype.animate function in regular fashion or pass it to our polyfill\n *  so its current time is driven by scroll event\n * @param keyframes {Object} array of keyframe objects\n * @param options {Object} WAAPI options object\n * @returns {Function}\n */\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nlet proxyAnimations = new WeakMap();\nexport class ProxyAnimation {\n  constructor(effect, timeline) {\n    if (effect instanceof nativeAnimation) {\n      proxyAnimations.set(this, {\n        animation: effect,\n        timeline,\n        playState: \"idle\",\n      });\n      return;\n    }\n    const isScrollAnimation = timeline && timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxyAnimations.set(this, {\n      animation: new nativeAnimation(effect, animationTimeline),\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n    });\n  }\n\n  get effect() {\n    return proxyAnimations.get(this).animation.effect;\n  }\n  set effect(newEffect) {\n    return proxyAnimations.get(this).animation.effect = newEffect;\n  }\n\n  get timeline() {\n    const internalTimeline = proxyAnimations.get(this).timeline;\n    if (internalTimeline !== undefined)\n      return internalTimeline;\n    return proxyAnimations.get(this).animation.timeline;\n  }\n\n  get startTime() {\n    const internalPlayState = proxyAnimations.get(this).playState;\n    if (!internalPlayState)\n      return proxyAnimations.get(this).animation.startTime;\n    if (internalPlayState == \"running\")\n      return 0;\n    return null;\n  }\n  set startTime(value) {\n    proxyAnimations.get(this).animation.startTime = value;\n  }\n\n  get currentTime() {\n    return proxyAnimations.get(this).animation.currentTime;\n  }\n  set currentTime(value) {\n    proxyAnimations.get(this).animation.currentTime = value;\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    proxyAnimations.get(this).animation.playbackRate = value;\n  }\n\n  get playState() {\n    const internalPlayState = proxyAnimations.get(this).playState;\n    if (internalPlayState)\n      return internalPlayState;\n    return proxyAnimations.get(this).animation.playState;\n  }\n\n  get replaceState() {\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  finish() {\n    proxyAnimations.get(this).animation.finish();\n    let internalTimeline = proxyAnimations.get(this).timeline;\n    if (!internalTimeline) {\n      proxyAnimations.get(this).animation.play();\n      return;\n    }\n    if (proxyAnimations.get(this).playState == \"finished\")\n      return;\n    proxyAnimations.get(this).playState = \"finished\";\n    removeAnimation(internalTimeline, proxyAnimations.get(this).animation);\n  }\n\n  play() {\n    let internalTimeline = proxyAnimations.get(this).timeline;\n    if (!internalTimeline) {\n      proxyAnimations.get(this).animation.play();\n      return;\n    }\n    if (proxyAnimations.get(this).animation.playState != \"paused\") {\n      proxyAnimations.get(this).animation.play();\n      proxyAnimations.get(this).animation.pause();\n    }\n    if (proxyAnimations.get(this).playState == \"running\")\n      return;\n    addAnimation(internalTimeline, proxyAnimations.get(this).animation);\n    proxyAnimations.get(this).playState = \"running\";\n  }\n\n  pause() {\n    let internalTimeline = proxyAnimations.get(this).timeline;\n    if (!internalTimeline) {\n      proxyAnimations.get(this).animation.pause();\n      return;\n    }\n    if (proxyAnimations.get(this).playState == \"paused\")\n      return;\n    proxyAnimations.get(this).playState = \"paused\";\n    removeAnimation(internalTimeline, proxyAnimations.get(this).animation);\n  }\n\n  reverse() {\n    proxyAnimations.get(this).animation.reverse();\n  }\n\n  updatePlaybackRate(rate) {\n    proxyAnimations.get(this).animation.updatePlaybackRate(rate);\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n\n  cancel() {\n    proxyAnimations.get(this).animation.cancel();\n    let internalTimeline = proxyAnimations.get(this).timeline;\n    if (!internalTimeline)\n      return;\n    if (proxyAnimations.get(this).playState == \"idle\" ||\n        proxyAnimations.get(this).playState == \"finished\")\n      return;\n    if (proxyAnimations.get(this).playState == \"running\")\n      removeAnimation(internalTimeline, proxyAnimations.get(this).animation);\n    proxyAnimations.get(this).playState = \"finished\";\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    proxyAnimations.get(this).animation.finished;\n  }\n\n  get ready() {\n    proxyAnimations.get(this).animation.ready;\n  }\n\n};\n\nexport function animate(keyframes, options) {\n  let timeline = options.timeline;\n  if (!timeline || !(timeline instanceof ScrollTimeline)) {\n    return nativeElementAnimate.apply(this, [keyframes, options]);\n  }\n  delete options.timeline;\n  let animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  // TODO: Create a proxy for the animation to control and fake the animation\n  // play state.\n  animation.pause();\n  let proxyAnimation = new ProxyAnimation(animation, timeline);\n  proxyAnimation.play();\n  return proxyAnimation;\n};\n\n\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a RangeError for out of range threshold:\n    // https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n    if (threshold < 0 || threshold > 1)\n      throw RangeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i]);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"%\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\n\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\nif (!Reflect.defineProperty(window, \"Animation\", {value: ProxyAnimation})) {\n  throw Error(\"Error installing Animation constructor.\");\n}\n"],"names":["parseLength","str","matches","trim","match","value","unit","AUTO","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","currentTime","i","playState","cancel","calculateScrollOffset","autoValue","orientation","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","parsed","parseFloat","removeAnimation","scrollTimeline","animation","index","indexOf","splice","ScrollTimeline","options","set","this","startScrollOffset","endScrollOffset","timeRange","fill","_createClass","element","removeEventListener","_this","Element","addEventListener","currentStlOptions","startScrollOffsetFunction","result","parse","undefined","evaluate","endScrollOffsetFunction","startOffset","endOffset","Math","max","effect","getComputedTiming","activeDuration","Infinity","calculateTimeRange","currentScrollOffset","scrollTop","scrollLeft","nativeElementAnimate","window","prototype","animate","nativeAnimation","Animation","proxyAnimations","ProxyAnimation","timeline","isScrollAnimation","finish","internalTimeline","play","pause","push","reverse","updatePlaybackRate","rate","persist","newEffect","internalPlayState","startTime","playbackRate","pending","id","onfinish","oncancel","onremove","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","RangeError","margins","split","TypeError","parsedMargins","parsedValue","positions","j","map","margin","join","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","apply","proxyAnimation"],"mappings":"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"}